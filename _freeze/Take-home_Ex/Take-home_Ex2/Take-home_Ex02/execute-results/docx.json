{
  "hash": "ab49132d4f7c0e447148ddf3fcf14d4e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 2\"\nauthor: \"Yi Fang\"\ndate: \"May 28, 2025\"\ndate-modified: \"last-modified\"\neditor: visual\nfreeze: true\nwarning: false\nformat: docx\ncategories: \n  - [\"Take-home Exercise\"]\n---\n\n\n\n# 1 Overview\n\nThis take-home exercise will be done in reference to the [VAST Challenge 2025](https://vast-challenge.github.io/2025/MC1.html) and provide solutions to the first question of Mini-Challenge 1.\n\n## 1.1 Background\n\nOne of music’s biggest superstars is Oceanus native Sailor Shift. From humble beginnings, Sailor has grown in popularity and now enjoys fans around the world. Sailor started her career on the island nation of Oceanus which can be clearly seen in her early work, she started in the genre of “Oceanus Folk”. While Sailor has moved away from the traditional Oceanus style, the Oceanus Folk has made a name for itself in the musical world. The popularity of this music is one of the factors driving an increase in tourism to a quiet island nation that used to be known for fishing.\n\nIn 2023, Sailor Shift joined the Ivy Echoes – an all-female Oceanus Folk band consisting of Sailor (vocalist), Maya Jensen (vocalist), Lila “Lilly” Hartman (guitarist), Jade Thompson (drummer), and Sophie Ramirez (bassist). They played together at venues throughout Oceanus but had broken up to pursue their individual careers by 2026. Sailor’s breakthrough came in 2028 when one of her singles went viral, launched to the top of the global charts (something no other Oceanus Folk song had ever done). Since then, she has only continued to grow in popularity worldwide.\n\nSailor has released a new album almost every year since her big break, and each has done better than the last. Although she has remained primarily a solo artist, she has also frequently collaborated with other established artists, especially in the Indie Pop and Indie Folk genres. She herself has branched out musically over the years but regularly returns to the Oceanus Folk genre — even as the genre’s influence on the rest of the music world has spread even more.\n\nSailor has always been passionate about two things: (1) spreading Oceanus Folk, and (2) helping lesser-known artists break into music. Because of those goals, she’s particularly famous for her frequent collaborations.\n\nAdditionally, because of Sailor’s success, more attention began to be paid over the years to her previous bandmates. All 4 have continued in the music industry—Maya as an independent vocalist, Lilly and Jade as instrumentalists in other bands, and Sophie as a music producer for a major record label. In various ways, all of them have contributed to the increased influence of Oceanus folk, resulting in a new generation of up-and-coming Oceanus Folk artists seeking to make a name for themselves in the music industry.\n\nNow, as Sailor returns to Oceanus in 2040, a local journalist – Silas Reed – is writing a piece titled Oceanus Folk: Then-and-Now that aims to trace the rise of Sailor and the influence of Oceanus Folk on the rest of the music world. He has collected a large dataset of musical artists, producers, albums, songs, and influences and organized it into a knowledge graph. Your task is to help Silas create beautiful and informative visualizations of this data and uncover new and interesting information about Sailor’s past, her rise to stardom, and her influence.\n\n## 1.2 Tasks and Questions\n\nThe objective of this take-home exercise is to address the following tasks and questions of VAST Challenge 2025's Mini-Challenge 1.\n\n1.  Design and develop visualizations and visual analytic tools that will allow Silas to explore and understand the profile of Sailor Shift’s career\n\n    a.  Who has she been most influenced by over time?\n\n    b.  Who has she collaborated with and directly or indirectly influenced?\n\n    c.  How has she influenced collaborators of the broader Oceanus Folk community?\n\n# 2 Getting Started\n\n## 2.1 Load the packages\n\nIn the code chunk below, `p_load()` of **pacman** package is used to load the R packages into R environemnt.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(jsonlite, tidyverse, ggtext,\n                knitr, lubridate, patchwork,\n                ggraph, tidygraph, igraph, scales,\n                ggiraph, dplyr, stringr, ggnewscale)\n```\n:::\n\n\n\n## 2.2 Importing Knowledge Graph Data\n\n`fromJSON()` of **jsonlite** package is used to import *MC1_graph.json* file into R and save the output object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_data <- fromJSON(\"MC1/data/MC1_graph.json\")\n```\n:::\n\n\n\n### 2.2.1 Inspect structure\n\nHere, `str()` is used to reveal the structure of *mc1_data* object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(mc1_data, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\n\n## 2.3 Extracting the edges and nodes tables\n\nNext, `as_tibble()` of **tibble** package package is used to extract the nodes and links tibble data frames from *mc1_data* object into two separate tibble data frames called *mc1_nodes_raw* and *mc1_edges_raw* respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw <- as_tibble(mc1_data$nodes)\nglimpse(mc1_nodes_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 17,412\nColumns: 10\n$ `Node Type`    <chr> \"Song\", \"Person\", \"Person\", \"Person\", \"RecordLabel\", \"S…\n$ name           <chr> \"Breaking These Chains\", \"Carlos Duffy\", \"Min Qin\", \"Xi…\n$ single         <lgl> TRUE, NA, NA, NA, NA, FALSE, NA, NA, NA, NA, TRUE, NA, …\n$ release_date   <chr> \"2017\", NA, NA, NA, NA, \"2026\", NA, NA, NA, NA, \"2020\",…\n$ genre          <chr> \"Oceanus Folk\", NA, NA, NA, NA, \"Lo-Fi Electronica\", NA…\n$ notable        <lgl> TRUE, NA, NA, NA, NA, TRUE, NA, NA, NA, NA, TRUE, NA, N…\n$ id             <int> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n$ written_date   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \"2020\", NA, NA,…\n$ stage_name     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ notoriety_date <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n```\n\n\n:::\n\n```{.r .cell-code}\nkable(head(mc1_nodes_raw, 5))\n```\n\n::: {.cell-output-display}\n\n\n|Node Type   |name                  |single |release_date |genre        |notable | id|written_date |stage_name |notoriety_date |\n|:-----------|:---------------------|:------|:------------|:------------|:-------|--:|:------------|:----------|:--------------|\n|Song        |Breaking These Chains |TRUE   |2017         |Oceanus Folk |TRUE    |  0|NA           |NA         |NA             |\n|Person      |Carlos Duffy          |NA     |NA           |NA           |NA      |  1|NA           |NA         |NA             |\n|Person      |Min Qin               |NA     |NA           |NA           |NA      |  2|NA           |NA         |NA             |\n|Person      |Xiuying Xie           |NA     |NA           |NA           |NA      |  3|NA           |NA         |NA             |\n|RecordLabel |Nautical Mile Records |NA     |NA           |NA           |NA      |  4|NA           |NA         |NA             |\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_edges_raw <- as_tibble(mc1_data$links)\n\nglimpse(mc1_edges_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 37,857\nColumns: 4\n$ `Edge Type` <chr> \"InterpolatesFrom\", \"RecordedBy\", \"PerformerOf\", \"Composer…\n$ source      <int> 0, 0, 1, 1, 2, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5…\n$ target      <int> 1841, 4, 0, 16180, 0, 16180, 0, 5088, 14332, 11677, 2479, …\n$ key         <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n```\n\n\n:::\n\n```{.r .cell-code}\nkable(head(mc1_edges_raw, 5))\n```\n\n::: {.cell-output-display}\n\n\n|Edge Type        | source| target| key|\n|:----------------|------:|------:|---:|\n|InterpolatesFrom |      0|   1841|   0|\n|RecordedBy       |      0|      4|   0|\n|PerformerOf      |      1|      0|   0|\n|ComposerOf       |      1|  16180|   0|\n|PerformerOf      |      2|      0|   0|\n\n\n:::\n:::\n\n\n\n## 2.4 Data Overview\n\nBefore proceeding to data pre-processing, we examine the data to gain a clearer understanding of the dataset and to verify the structural integrity of the imported graph.\n\nIn this code chunk below, ggplot2 functions are used the reveal the frequency distribution of *Node Type* field of *mc1_nodes_raw*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc1_nodes_raw,\n       aes(y = `Node Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-6-1.png)\n:::\n:::\n\n\n\nOn the other hand, code chunk below uses ggplot2 functions to reveal the frequency distribution of *Edge Type* field of *mc1_edges_raw*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc1_edges_raw,\n       aes(y = `Edge Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-7-1.png)\n:::\n:::\n\n\n\n# 3 Data Pre-processing\n\n## 3.1 Adding identifying columns\n\nAs a large part of this mini-challenge centers around Sailor Shift and the genre of \"Oceanus Folk\", the following code will add columns to help with identification and filtering of Sailor Shift and the work in the genre of \"Oceanus Folk\". This will help with analysis in addressing the questions and tasks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw <- mc1_nodes_raw %>%\n  mutate(\n    is_sailor = (\n      str_detect(name, regex(\"sailor shift\", ignore_case = TRUE))\n    ) %>% replace_na(FALSE),\n    \n    is_oceanus_folk = str_detect(genre, regex(\"oceanus folk\", ignore_case = TRUE)) %>% #na/not oceanus folk = false\n      replace_na(FALSE)\n  )\n```\n:::\n\n\n\n## 3.2 Converting date field\n\nDate fields will be converted from *chr* to *int* for later analysis. Note that dates only appear for *Song* and *Album*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw <- mc1_nodes_raw %>%\n  mutate(across(c(release_date, notoriety_date, written_date),\n                ~as.integer(if_else(`Node Type` %in% c(\"Song\", \"Album\"), ., NA_character_))))\n```\n:::\n\n\n\n## 3.3 Check for duplicates\n\n### 3.3.1 Check for duplicates in *mc1_nodes_raw*\n\nThe following code chunk checks for *id* duplicates in *mc1_nodes_raw.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw %>%\n  count(id) %>%\n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 2\n# ℹ 2 variables: id <int>, n <int>\n```\n\n\n:::\n:::\n\n\n\nThere are no duplicated *id* in *mc1_nodes_raw*.\n\nThe following code checks for *name* duplicates in *mc1_nodes_raw*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicated_name <- mc1_nodes_raw %>%\n  count(name) %>%\n  filter(n > 1)\n\nduplicated_name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,611 × 2\n   name                 n\n   <chr>            <int>\n 1 Agata Records        2\n 2 Ancestral Echoes     2\n 3 Angela Thompson      2\n 4 Anthony Davis        2\n 5 Anthony Smith        2\n 6 Asuka Takahashi      3\n 7 Brandon Wilson       2\n 8 Brian Gonzalez       2\n 9 Bryan Garcia         2\n10 Bryan Smith          3\n# ℹ 1,601 more rows\n```\n\n\n:::\n:::\n\n\n\nThe following code chunk shows all rows from *mc1_nodes_raw* that have duplicated names, and sorting them alphabetically by the *name* column. There are a total of 4,953 records with duplicated names in *mc1_nodes_raw*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw %>%\n  filter(name %in% duplicated_name$name) %>%\n  arrange(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,953 × 12\n   `Node Type` name         single release_date genre notable    id written_date\n   <chr>       <chr>        <lgl>         <int> <chr> <lgl>   <int>        <int>\n 1 RecordLabel Agata Recor… NA               NA <NA>  NA       1528           NA\n 2 RecordLabel Agata Recor… NA               NA <NA>  NA      17388           NA\n 3 Song        Ancestral E… TRUE           1991 Drea… FALSE   11793           NA\n 4 Song        Ancestral E… FALSE          2039 Avan… TRUE    17133           NA\n 5 Person      Angela Thom… NA               NA <NA>  NA       1150           NA\n 6 Person      Angela Thom… NA               NA <NA>  NA      13448           NA\n 7 Person      Anthony Dav… NA               NA <NA>  NA       8692           NA\n 8 Person      Anthony Dav… NA               NA <NA>  NA      12452           NA\n 9 Person      Anthony Smi… NA               NA <NA>  NA       5719           NA\n10 Person      Anthony Smi… NA               NA <NA>  NA       7694           NA\n# ℹ 4,943 more rows\n# ℹ 4 more variables: stage_name <chr>, notoriety_date <int>, is_sailor <lgl>,\n#   is_oceanus_folk <lgl>\n```\n\n\n:::\n:::\n\n\n\n### 3.3.2 Fixing duplicates in *mc1_nodes_raw*\n\nThe section will focus on fixing the duplicates found in *mc1_nodes_raw* as identified in section 3.3.1*.*\n\nThe following code chunk will tag each row with a unique key (*group_key*) based on its respective column values. This helps to identify unique records.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Mark all node rows with a hash key for grouping\nmc1_nodes_tagged <- mc1_nodes_raw %>%\n  mutate(group_key = paste(`Node Type`, name, single, release_date, genre,\n                           notable, written_date, notoriety_date, is_sailor,\n                           is_oceanus_folk, sep = \"|\"))\n\nmc1_nodes_tagged\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 17,412 × 13\n   `Node Type` name         single release_date genre notable    id written_date\n   <chr>       <chr>        <lgl>         <int> <chr> <lgl>   <int>        <int>\n 1 Song        Breaking Th… TRUE           2017 Ocea… TRUE        0           NA\n 2 Person      Carlos Duffy NA               NA <NA>  NA          1           NA\n 3 Person      Min Qin      NA               NA <NA>  NA          2           NA\n 4 Person      Xiuying Xie  NA               NA <NA>  NA          3           NA\n 5 RecordLabel Nautical Mi… NA               NA <NA>  NA          4           NA\n 6 Song        Unshackled … FALSE          2026 Lo-F… TRUE        5           NA\n 7 Person      Luke Payne   NA               NA <NA>  NA          6           NA\n 8 Person      Xiulan Zeng  NA               NA <NA>  NA          7           NA\n 9 Person      David Frank… NA               NA <NA>  NA          8           NA\n10 RecordLabel Colline-Cas… NA               NA <NA>  NA          9           NA\n# ℹ 17,402 more rows\n# ℹ 5 more variables: stage_name <chr>, notoriety_date <int>, is_sailor <lgl>,\n#   is_oceanus_folk <lgl>, group_key <chr>\n```\n\n\n:::\n:::\n\n\n\nThe code below deduplicates the dataset using *group_key*, reducing the number of duplicated names from 4,953 to 14. The remaining 14 names appear more than once because their corresponding records differ in at least one column used to form *group_key*, so they are retained as distinct entries.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 2: Deduplicate and keep the preferred (with stage_name if available)\nmc1_nodes_dedup <- mc1_nodes_tagged %>%\n  group_by(group_key) %>%\n  arrange(desc(!is.na(stage_name))) %>%\n  slice(1) %>%\n  ungroup()\n\nduplicated_name <- mc1_nodes_dedup %>%\n  count(name) %>%\n  filter(n > 1)\n\nmc1_nodes_raw %>%\n  filter(name %in% duplicated_name$name) %>%\n  arrange(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 12\n   `Node Type` name         single release_date genre notable    id written_date\n   <chr>       <chr>        <lgl>         <int> <chr> <lgl>   <int>        <int>\n 1 Song        Ancestral E… TRUE           1991 Drea… FALSE   11793           NA\n 2 Song        Ancestral E… FALSE          2039 Avan… TRUE    17133           NA\n 3 RecordLabel Coastal Ech… NA               NA <NA>  NA       4022           NA\n 4 Album       Coastal Ech… NA             2023 Psyc… TRUE    15065         2019\n 5 Song        Postcards f… TRUE           2023 Indi… TRUE    12852         2023\n 6 Song        Postcards f… FALSE          1984 Acou… FALSE   17214           NA\n 7 Album       Shattered R… NA             2013 Emo/… TRUE     3325         2013\n 8 Song        Shattered R… FALSE          2036 Dark… TRUE    17088           NA\n 9 Song        Unheard Fre… TRUE           2025 Alte… TRUE     7999           NA\n10 RecordLabel Unheard Fre… NA               NA <NA>  NA      10952           NA\n11 Song        Vanishing P… TRUE           2018 Avan… TRUE     9371         2018\n12 Song        Vanishing P… FALSE          2013 Ocea… FALSE   17338           NA\n13 RecordLabel Vertical Ho… NA               NA <NA>  NA       2453           NA\n14 Album       Vertical Ho… NA             2017 Doom… TRUE     9262           NA\n# ℹ 4 more variables: stage_name <chr>, notoriety_date <int>, is_sailor <lgl>,\n#   is_oceanus_folk <lgl>\n```\n\n\n:::\n:::\n\n\n\n### 3.3.3 Check for duplicates in *mc1_edges_raw*\n\nThe following code proceeds to check for duplicates in *mc1_edges_raw.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Identify duplicate combinations\nduplicate_summary <- mc1_edges_raw %>%\n  count(source, target, `Edge Type`) %>%\n  filter(n > 1)\n\n# Step 2: Join back to get all original duplicate rows\nmc1_edges_raw %>%\n  inner_join(duplicate_summary, by = c(\"source\", \"target\", \"Edge Type\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  `Edge Type` source target   key     n\n  <chr>        <int>  <int> <int> <int>\n1 PerformerOf  17057  17058     0     2\n2 PerformerOf  17057  17058     1     2\n3 PerformerOf  17349  17350     0     2\n4 PerformerOf  17349  17350     2     2\n5 PerformerOf  17355  17356     0     2\n6 PerformerOf  17355  17356     2     2\n```\n\n\n:::\n:::\n\n\n\nThere are duplicates as seen above, with only differences in *key*. As *key* will not be used in subsequent data analysis, the duplicated edges will be removed with the following code.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_edges_raw <- mc1_edges_raw %>%\n  distinct(source, target, `Edge Type`, .keep_all = TRUE) %>%\n  select(!key)\n\nmc1_edges_raw %>%\n  count(source, target, `Edge Type`) %>%\n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 4\n# ℹ 4 variables: source <int>, target <int>, Edge Type <chr>, n <int>\n```\n\n\n:::\n:::\n\n\n\n# 4 EDA\n\n## 4.1 Explore and inspect Nodes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_raw$release_date %>% unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2017   NA 2026 2020 2027 2022 2007 2010 2003 2023 1997 2013 2000 2025 2029\n[16] 2015 2018 2016 2014 2028 2021 2030 2011 1994 2004 1998 1991 1999 2024 2012\n[31] 2002 2006 2008 2019 1995 1989 2032 2009 2001 1996 1990 1984 2005 1993 1986\n[46] 1985 1981 1992 1987 1988 1983 2031 1975 2035 2033 2037 2036 2039 2038 2034\n[61] 1977 1979 1980 1982 2040\n```\n\n\n:::\n\n```{.r .cell-code}\nmc1_nodes_raw %>%\n  filter(grepl(\"Sailor Shift\", name)) #Sailor Shift is in name column and not in stage_name column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 12\n  `Node Type` name         single release_date genre notable    id written_date\n  <chr>       <chr>        <lgl>         <int> <chr> <lgl>   <int>        <int>\n1 Person      Sailor Shift NA               NA <NA>  NA      17255           NA\n# ℹ 4 more variables: stage_name <chr>, notoriety_date <int>, is_sailor <lgl>,\n#   is_oceanus_folk <lgl>\n```\n\n\n:::\n:::\n\n\n\n`'` will be removed from *name* to prevent issues with tooltip in tidygraph.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_clean <- mc1_nodes_raw %>%\n  mutate(\n    name = gsub(\"'\", \"\", name)) \n  \nkable(head(mc1_nodes_clean))\n```\n\n::: {.cell-output-display}\n\n\n|Node Type   |name                  |single | release_date|genre             |notable | id| written_date|stage_name | notoriety_date|is_sailor |is_oceanus_folk |\n|:-----------|:---------------------|:------|------------:|:-----------------|:-------|--:|------------:|:----------|--------------:|:---------|:---------------|\n|Song        |Breaking These Chains |TRUE   |         2017|Oceanus Folk      |TRUE    |  0|           NA|NA         |             NA|FALSE     |TRUE            |\n|Person      |Carlos Duffy          |NA     |           NA|NA                |NA      |  1|           NA|NA         |             NA|FALSE     |FALSE           |\n|Person      |Min Qin               |NA     |           NA|NA                |NA      |  2|           NA|NA         |             NA|FALSE     |FALSE           |\n|Person      |Xiuying Xie           |NA     |           NA|NA                |NA      |  3|           NA|NA         |             NA|FALSE     |FALSE           |\n|RecordLabel |Nautical Mile Records |NA     |           NA|NA                |NA      |  4|           NA|NA         |             NA|FALSE     |FALSE           |\n|Song        |Unshackled Heart      |FALSE  |         2026|Lo-Fi Electronica |TRUE    |  5|           NA|NA         |             NA|FALSE     |FALSE           |\n\n\n:::\n:::\n\n\n\n## 4.2 Explore and inspect Edges\n\nThe following code chunk is used to ensure that *id* used in *mc1_edges_raw* matches the range range of *id* in *mc1_nodes_clean.*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(mc1_nodes_clean$id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     0 17411\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(mc1_edges_raw$source)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     0 17411\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(mc1_edges_raw$target)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     0 17411\n```\n\n\n:::\n:::\n\n\n\n## 4.3 Mapping Node name to Edges id\n\ntidygraph uses *from* and *to* columns to reference nodes. By default, tidygraph matches these edges reference against the first column in the nodes table, or against *name* column.\n\nCurrently, *source* and *target* columns in *mc1_edges_raw* contain *id* values that correspond to the *id* column in *mc1_nodes_clean*. To properly integrate with tidygraph's conventions, the following will be done:\n\n1.  Restructure *mc1_nodes_clean*\n    a.  Rename the current *name* column to *node_name* - this is done to preserve the actual node names\n    b.  Rename the *id* column to *name* so it becomes the primary identifier column that tidygraph will use for matching\n2.  Rename *source* and *target* columns in *mc1_edges_raw*, as required by tidygraph\n3.  Ensure data type consistency: Convert the *name* column (formerly *id*) to character format to match the data type of the edge references\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_nodes_clean <- mc1_nodes_dedup %>%\n  rename(node_name = name, name = id) %>%\n  mutate(name = as.character(name)) %>%\n  select(`Node Type`, node_name, release_date, genre, notable, name, single, written_date, stage_name, notoriety_date, is_sailor, is_oceanus_folk)\n\nmc1_nodes_clean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14,077 × 12\n   `Node Type` node_name    release_date genre notable name  single written_date\n   <chr>       <chr>               <int> <chr> <lgl>   <chr> <lgl>         <int>\n 1 Album       A Lush Dyst…         2031 Psyc… TRUE    17005 NA             2030\n 2 Album       Addicted to…         2004 Sout… TRUE    14658 NA             2000\n 3 Album       Adriatic Em…         2013 Post… TRUE    10412 NA               NA\n 4 Album       Aerial Echo…         2023 Indi… TRUE    7908  NA               NA\n 5 Album       Aftershock …         2028 Drea… TRUE    2030  NA             2021\n 6 Album       Allegretto …         2020 Indi… TRUE    6251  NA               NA\n 7 Album       Alleys and …         2029 Jazz… TRUE    1310  NA               NA\n 8 Album       Alloy Archi…         2017 Indi… TRUE    8428  NA             2017\n 9 Album       Almost (But…         2027 Alte… TRUE    14611 NA             2027\n10 Album       Altar of De…         2020 Ocea… TRUE    5883  NA               NA\n# ℹ 14,067 more rows\n# ℹ 4 more variables: stage_name <chr>, notoriety_date <int>, is_sailor <lgl>,\n#   is_oceanus_folk <lgl>\n```\n\n\n:::\n:::\n\n\n\n### 4.3.1 Creating edge mapping from old id to kept id\n\nIn section 3.3.2, duplicated nodes were deduplicated and removed, edges referring to the removed nodes will become invalid thus, edges will be remapped to the retained nodes. This ensures that all edges correctly point to existing nodes in the deduplicated graph.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create mapping of all group_key → kept id\nkey_to_id_map <- mc1_nodes_dedup %>%\n  select(group_key, kept_id = id)\n\n# Step 2: Map all original rows to the retained ID\nid_remap <- mc1_nodes_tagged %>%\n  left_join(key_to_id_map, by = \"group_key\") %>%\n  select(original_id = id, kept_id)\n\nid_remap\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 17,412 × 2\n   original_id kept_id\n         <int>   <int>\n 1           0       0\n 2           1       1\n 3           2   14470\n 4           3       3\n 5           4       4\n 6           5       5\n 7           6       6\n 8           7       7\n 9           8       8\n10           9       9\n# ℹ 17,402 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 3: Replace edges' source and target with mapped kept_id\nmc1_edges_mapped <- mc1_edges_raw %>%\n  left_join(id_remap, by = c(\"source\" = \"original_id\"))\n\nmc1_edges_mapped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 37,854 × 4\n   `Edge Type`      source target kept_id\n   <chr>             <int>  <int>   <int>\n 1 InterpolatesFrom      0   1841       0\n 2 RecordedBy            0      4       0\n 3 PerformerOf           1      0       1\n 4 ComposerOf            1  16180       1\n 5 PerformerOf           2      0   14470\n 6 ProducerOf            2  16180   14470\n 7 PerformerOf           3      0       3\n 8 InterpolatesFrom      5   5088       5\n 9 InStyleOf             5  14332       5\n10 InterpolatesFrom      5  11677       5\n# ℹ 37,844 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_edges_mapped <- mc1_edges_mapped %>%\n  mutate(source = kept_id) %>%\n  select(-kept_id) %>%\n  left_join(id_remap, by = c(\"target\" = \"original_id\")) %>%\n  mutate(target = kept_id) %>%\n  select(-kept_id) %>%\n  rename(from = source, to = target) %>%\n  mutate(from = as.character(from), to = as.character(to))\n\nmc1_edges_mapped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 37,854 × 3\n   `Edge Type`      from  to   \n   <chr>            <chr> <chr>\n 1 InterpolatesFrom 0     1841 \n 2 RecordedBy       0     4    \n 3 PerformerOf      1     0    \n 4 ComposerOf       1     16180\n 5 PerformerOf      14470 0    \n 6 ProducerOf       14470 16180\n 7 PerformerOf      3     0    \n 8 InterpolatesFrom 5     5088 \n 9 InStyleOf        5     14332\n10 InterpolatesFrom 5     11677\n# ℹ 37,844 more rows\n```\n\n\n:::\n:::\n\n\n\n## 4.4 Remove unmatched edges\n\nThe following code chunk removes edges that reference missing node id, ensuring that only valid edges are kept.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc1_edges_clean <- mc1_edges_mapped %>%\n  filter(!is.na(from), !is.na(to))\n```\n:::\n\n\n\nThere are no unmatched edges.\n\n## 4.5 Check for missing nodes\n\nThe following code chunk checks for missing nodes being referenced in *mc1_edges_clean* that do not exist in *mc1_nodes_clean*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(\n  unique(c(mc1_edges_clean$from, mc1_edges_clean$to)),\n  mc1_nodes_clean$name\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\nThere are no missing nodes.\n\n## 4.6 Validate Edges Schema\n\nThis section aims to ensure that each edge in the graph adheres to the schema specified in the VAST Challenge 2025 MC1 Data Description document. The following code checks whether the node types connect by each edge matches the valid source and target types for that edge's type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define valid source and destination types for each edge type\nedge_rules <- list(\n  PerformerOf = list(source = c(\"Person\", \"MusicalGroup\"), target = c(\"Song\", \"Album\")),\n  ComposerOf = list(source = c(\"Person\"), target = c(\"Song\", \"Album\")),\n  ProducerOf = list(source = c(\"Person\", \"RecordLabel\"), target = c(\"Song\", \"Album\", \"Person\", \"MusicalGroup\")),\n  LyricistOf = list(source = c(\"Person\"), target = c(\"Song\", \"Album\")),\n  RecordedBy = list(source = c(\"Song\", \"Album\"), target = c(\"RecordLabel\")),\n  DistributedBy = list(source = c(\"Song\", \"Album\"), target = c(\"RecordLabel\")),\n  InStyleOf = list(source = c(\"Song\", \"Album\"), target = c(\"Song\", \"Album\", \"Person\", \"MusicalGroup\")),\n  InterpolatesFrom = list(source = c(\"Song\", \"Album\"), target = c(\"Song\", \"Album\")),\n  CoverOf = list(source = c(\"Song\", \"Album\"), target = c(\"Song\", \"Album\")),\n  LyricalReferenceTo = list(source = c(\"Song\", \"Album\"), target = c(\"Song\", \"Album\")),\n  DirectlySamples = list(source = c(\"Song\", \"Album\"), target = c(\"Song\", \"Album\")),\n  MemberOf = list(source = c(\"Person\"), target = c(\"MusicalGroup\"))\n)\n```\n:::\n\n\n\nThe following code chunk checks for any erroneous edge and node relationships defined in the code chunk above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a lookup for node types\nnode_type_lookup <- mc1_nodes_clean %>%\n  select(name, `Node Type`) %>%\n  deframe()\n\n# Add source and target node types to the edge table\nmc1_edges_checked <- mc1_edges_clean %>%\n  mutate(\n    source_type = node_type_lookup[from],\n    target_type = node_type_lookup[to]\n  )\n\nmc1_edges_tagged <- mc1_edges_checked %>%\n  rowwise() %>%\n  mutate(\n    valid = {\n      rule <- edge_rules[[`Edge Type`]]\n      if (is.null(rule)) TRUE\n      else {\n        source_type %in% rule$source && target_type %in% rule$target\n      }\n    }\n  ) %>%\n  ungroup()\n\n# Count and display invalid edge combinations\ninvalid_edge_summary <- mc1_edges_tagged %>%\n  filter(!valid) %>%\n  count(`Edge Type`, source_type, target_type, sort = TRUE)\n\nprint(invalid_edge_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 4\n   `Edge Type`      source_type  target_type      n\n   <chr>            <chr>        <chr>        <int>\n 1 LyricistOf       MusicalGroup Song           106\n 2 RecordedBy       RecordLabel  Album          102\n 3 ProducerOf       MusicalGroup Song           100\n 4 ComposerOf       MusicalGroup Song            97\n 5 ProducerOf       MusicalGroup Album           31\n 6 LyricistOf       MusicalGroup Album           28\n 7 ComposerOf       MusicalGroup Album           17\n 8 InStyleOf        MusicalGroup MusicalGroup    12\n 9 InStyleOf        Person       MusicalGroup    11\n10 InterpolatesFrom MusicalGroup MusicalGroup    10\n# ℹ 14 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check total invalid edge count\ncat(\"Total invalid edges:\", sum(!mc1_edges_tagged$valid), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTotal invalid edges: 550 \n```\n\n\n:::\n:::\n\n\n\nThere are 550 edges that do not adhere to the schema specified in the data description file provided. The following code will remove these edges.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Keep only valid edges\nmc1_edges_clean <- mc1_edges_tagged %>%\n  filter(valid) %>%\n  select(from, to, `Edge Type`)  # drop helper columns\n```\n:::\n\n\n\n## 4.7 Visualising Edge and Node types\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc1_edges_clean,\n       aes(y = `Edge Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-30-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mc1_nodes_clean,\n       aes(y = `Node Type`)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-31-1.png)\n:::\n:::\n\n\n\n## 4.8 Creating knowledge graph\n\ntbl_graph() is used to create tidygraph's graph object by using the following code chunk.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmusic = tbl_graph(edges = mc1_edges_clean,\n                             nodes = mc1_nodes_clean,\n                             directed = TRUE)\n\nclass(music)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n\n\n:::\n:::\n\n\n\nSeveral of the ggraph layouts involve randomisation. In order to ensure reproducibility, it is necessary to set the seed value before plotting by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n\n# 5 VAST Challenge 2025 Mini-Challenge 1\n\nFor Task 1, it is to design and develop visualizations and visual analytic tools that will allow Silas to explore and understand the profile of Sailor Shift’s career. We start off with a network visualisation to provide an overview of Sailor Shift's works throughout her career, as well as the various roles she played in these works.\n\n::: panel-tabset\n## Network Visualisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Step 1: Identify Sailor Shift using the is_sailor column\nsailor_vertex_name <- mc1_nodes_clean %>%\n  filter(is_sailor) %>%\n  pull(name) %>%\n  first()\n\n# Step 2: Prepare edges and nodes related to Sailor Shift\nsailor_edges <- mc1_edges_clean %>%\n  filter(from == sailor_vertex_name | to == sailor_vertex_name)\n\nsailor_node_names <- unique(c(sailor_edges$from, sailor_edges$to))\n\nsailor_nodes <- mc1_nodes_clean %>%\n  filter(name %in% sailor_node_names) %>%\n  distinct(name, .keep_all = TRUE)\n\n# Step 3: Build tbl_graph object and annotate nodes\ncareer_graph <- tbl_graph(nodes = sailor_nodes, edges = sailor_edges, directed = TRUE) %>%\n  activate(nodes) %>%\n  mutate(\n    node_color = ifelse(is_sailor, \"red\", \"grey30\"),\n    tooltip_text = paste0(\n      \"Name: \", node_name, \"\\n\",\n      \"Type: \", `Node Type`, \"\\n\",\n      ifelse(!is.na(genre), paste0(\"Genre: \", genre, \"\\n\"), \"\"),\n      ifelse(!is.na(release_date), paste0(\"Release: \", release_date, \"\\n\"), \"\")\n    )\n  )\n\n# Step 4: Extract layout coordinates\nlayout_df <- create_layout(career_graph, layout = \"fr\") %>%\n  as_tibble() %>%\n  select(name, x, y)\n\nnodes_plot <- career_graph %>%\n  as_tibble() %>%\n  left_join(layout_df, by = \"name\")\n\nedges_plot <- sailor_edges %>%\n  left_join(nodes_plot %>% select(name, x, y), by = c(\"from\" = \"name\")) %>%\n  rename(x_from = x, y_from = y) %>%\n  left_join(nodes_plot %>% select(name, x, y), by = c(\"to\" = \"name\")) %>%\n  rename(x_to = x, y_to = y)\n\n# Get Sailor Shift node coordinates for annotation\nsailor_coords <- nodes_plot %>%\n  filter(is_sailor) %>%\n  select(x, y)\n\n# Step 5: Plot with ggiraph\np <- ggplot() +\n  # Edge layer with its own color scale\n  geom_segment(\n    data = edges_plot,\n    aes(\n      x = x_from, y = y_from, xend = x_to, yend = y_to,\n      color = `Edge Type`\n    ),\n    alpha = 0.4, arrow = arrow(length = unit(3, 'mm'))\n  ) +\n  scale_color_brewer(palette = \"Dark2\", name = \"Edge Type\") +\n\n  # New color scale for nodes\n  ggnewscale::new_scale_color() +\n\n  geom_point_interactive(\n    data = nodes_plot,\n    aes(\n      x = x, y = y,\n      tooltip = tooltip_text,\n      data_id = name,\n      color = node_color,\n      shape = `Node Type`\n    ),\n    size = 4\n  ) +\n  scale_color_manual(\n    values = c(\"red\" = \"red\", \"grey30\" = \"grey30\")\n  ) +\n  guides(color = \"none\") +  # Remove node color legend\n\n  # Add Sailor Shift label in the middle of the graph\n  geom_text(\n    data = sailor_coords,\n    aes(x = x, y = y, label = \"Sailor Shift\"),\n    size = 6, fontface = \"bold\", color = \"red\", vjust = -1\n  ) +\n\n  theme_void() +\n  labs(title = \"Sailor Shift's Career Profile\") +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\")\n  )\n\ngirafe(ggobj = p, width_svg = 10, height_svg = 8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-34-1.png)\n:::\n:::\n\n\n\n## Role Summary\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Filter edges related to Sailor Shift\nsailor_edges <- mc1_edges_clean %>%\n  filter(from == sailor_vertex_name | to == sailor_vertex_name)\n\n# Count edges by Edge Type\nedge_counts <- sailor_edges %>%\n  count(`Edge Type`) %>%\n  arrange(desc(n))\n\n# Display as a simple table\nkable(edge_counts, col.names = c(\"Role (Edge Type)\", \"Count\"), caption = \"Sailor Shift's Career Roles\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Sailor Shift's Career Roles\n\n|Role (Edge Type) | Count|\n|:----------------|-----:|\n|PerformerOf      |    26|\n|LyricistOf       |    21|\n|MemberOf         |     1|\n|ProducerOf       |     1|\n\n\n:::\n:::\n\n\n\n## Summary of works\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Filter edges related to Sailor Shift\nsailor_edges <- mc1_edges_clean %>%\n  filter(from == sailor_vertex_name | to == sailor_vertex_name)\n\n# Get the names of nodes connected to Sailor Shift (excluding Sailor Shift themself)\nrelated_names <- unique(c(sailor_edges$from, sailor_edges$to))\nrelated_names <- setdiff(related_names, sailor_vertex_name)\n\n# Get node types for these connected nodes\nrelated_nodes <- mc1_nodes_clean %>%\n  filter(name %in% related_names)\n\n# Count by Node Type (Song, Album)\ntype_counts <- related_nodes %>%\n  filter(`Node Type` %in% c(\"Song\", \"Album\")) %>%\n  count(`Node Type`) %>%\n  arrange(desc(n))\n\n# Display as a simple table\nkable(type_counts, col.names = c(\"Type\", \"Count\"), caption = \"Number of Songs and Albums Related to Sailor Shift\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Number of Songs and Albums Related to Sailor Shift\n\n|Type  | Count|\n|:-----|-----:|\n|Album |    21|\n|Song  |    17|\n\n\n:::\n:::\n\n\n:::\n\nBased on the above, Sailor Shift is primarily a performer and lyricist, and a member of Ivy Echos, a musical group. She was a lyricist for 17 songs and performer of 21 albums. It also shows that Oceanic Records, a Record label, has participated in the production of her works.\n\n## 5.1 Question 1a - Who has she been most influenced by over time?\n\nThe network structure below shows how Sailor Shift's career has been influenced by others. PageRank is used to measure the overall influence of each person, musical group or work within the network. This captures both direct and indirect influences.\n\n::: panel-tabset\n## Network Visualisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Step 0: Get name of 'Sailor Shift'\nsailor_vertex_name <- mc1_nodes_clean %>%\n  filter(is_sailor == TRUE) %>%\n  pull(name) %>%\n  first()\n\n# Step 1: Find direct influence relationships from Sailor Shift\n# These are the artists/works that Sailor Shift has been influenced by\ndirect_influence_types <- c(\"InStyleOf\", \"CoverOf\", \"InterpolatesFrom\", \"LyricalReferenceTo\", \"DirectlySamples\")\n\nsailor_direct_influences <- mc1_edges_clean %>%\n  filter(from == sailor_vertex_name, \n         `Edge Type` %in% direct_influence_types)\n\n# Step 2: Get immediate neighbors (people/groups Sailor Shift works with)\nsailor_out_edges <- mc1_edges_clean %>%\n  filter(from == sailor_vertex_name)\n\nsailor_out_node_names <- sailor_out_edges$to\n\n# Step 3: Split into people/groups vs songs/albums\nsailor_person_group <- mc1_nodes_clean %>%\n  filter(name %in% sailor_out_node_names, `Node Type` %in% c(\"Person\", \"MusicalGroup\")) %>%\n  pull(name)\n\nsailor_songs_all <- mc1_nodes_clean %>%\n  filter(name %in% sailor_out_node_names, `Node Type` %in% c(\"Song\", \"Album\")) %>%\n  pull(name)\n\n# Step 4: For songs/albums, find their direct influences too\nsong_influences <- mc1_edges_clean %>%\n  filter(from %in% sailor_songs_all, \n         `Edge Type` %in% direct_influence_types)\n\n# Step 5: Get all influence targets (who influenced Sailor Shift or their works)\nall_influence_targets <- unique(c(\n  sailor_direct_influences$to,\n  song_influences$to\n))\n\n# Step 6: Get creators of Sailor Shift's works (indirect influence indicators)\ncreator_edge_types <- c(\"PerformerOf\", \"ComposerOf\", \"ProducerOf\", \"LyricistOf\")\n\nsailor_songs <- mc1_edges_clean %>%\n  filter(from %in% sailor_songs_all) %>%\n  pull(from) %>%\n  unique()\n\nsailor_songs_out_nodes <- mc1_edges_clean %>%\n  filter(from %in% sailor_songs) %>%\n  pull(to)\n\ncreator_edges <- mc1_edges_clean %>%\n  filter(to %in% sailor_songs_out_nodes, `Edge Type` %in% creator_edge_types)\n\nsailor_people_group_neighbourhood_nodes <- creator_edges %>%\n  pull(from) %>%\n  unique()\n\n# Step 7: Combine all relevant nodes for subgraph\nsailor_all_node_names <- unique(c(\n  sailor_vertex_name,\n  sailor_person_group,\n  sailor_songs,\n  sailor_songs_out_nodes,\n  sailor_people_group_neighbourhood_nodes,\n  all_influence_targets  \n))\n\n# Step 8: Create subgraph\nsub_music <- music %>%\n  filter(name %in% sailor_all_node_names)\n\n# Step 9: Calculate PageRank \nsub_music <- sub_music %>%\n  activate(nodes) %>%\n  mutate(\n    pagerank = centrality_pagerank()\n  )\n\n# Step 10: Set node size based on PageRank for people/groups, fixed for others\nsub_music <- sub_music %>%\n  mutate(\n    is_sailor = name == sailor_vertex_name,\n    node_color = ifelse(is_sailor, \"red\", \"grey30\"),\n    tooltip_text = sprintf(\n      \"Name: %s\\nType: %s\\nPageRank: %.4f\",\n      node_name, `Node Type`, pagerank\n    ),\n    node_size = case_when(\n      `Node Type` %in% c(\"Person\", \"MusicalGroup\") ~ rescale(pagerank, to = c(4, 20)),\n      TRUE ~ 4  \n    )\n  )\n\n# Step 11: Create visualization\ng <- sub_music %>%\n  ggraph(layout = \"fr\") +\n  geom_edge_link(\n    aes(color = `Edge Type`), \n    alpha = 0.3,\n    arrow = arrow(length = unit(3, 'mm')),\n    end_cap = circle(3, 'mm')\n  ) +\n  geom_point_interactive(\n    aes(\n      x = x, y = y,\n      data_id = name,\n      tooltip = tooltip_text,\n      shape = `Node Type`,\n      colour = node_color,\n      size = node_size\n    )\n  ) +\n  scale_shape_discrete(name = \"Node Type\") +\n  scale_colour_identity() +\n  scale_size_identity() +\n  theme_graph(base_family = \"sans\") +\n  labs(\n    title = \"Network of Influences on Sailor Shift\"\n  )\n\ngirafe(ggobj = g, width_svg = 10, height_svg = 8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-37-1.png)\n:::\n:::\n\n\n\n## Influence Summary\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Filter to people and groups only, exclude Sailor Shift node itself\ntop_influencers <- sub_music %>%\n  as_tibble() %>%\n  filter(\n    `Node Type` %in% c(\"Person\", \"MusicalGroup\"),\n    name != sailor_vertex_name\n  ) %>%\n  arrange(desc(pagerank)) %>%\n  slice_head(n = 5)\n\n# Plot\nggplot(top_influencers, aes(x = reorder(node_name, pagerank), y = pagerank, fill = `Node Type`)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  labs(\n    title = \"Top 5 Influences on Sailor Shift\",\n    x = \"Influencer\",\n    y = \"PageRank Score\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-38-1.png)\n:::\n:::\n\n\n:::\n\nBased on the PageRank score, it is noted that she is most influenced by musical groups as the top 3 most influences are musical groups. Phantom Roots have influenced her the most over time, this is followed by Ursus and the group she was a part of, Ivy Echos.\n\n## 5.2 Question 1b - Who has she collaborated with and directly or indirectly influenced?\n\nThe network visualisation below explores Sailor Shift's collaborations and influence. While the primary question centers on Sailor Shift, the analysis also incorporates Ivy Echos, the musical group that she was a member of. Including Ivy Echos is essential because Sailor Shift's creative impact can extend beyond her solo work as her contributions as part of Ivy Echos could have influenced others. The visualisation therefore highlights not just individuals and groups who have collaborated with Sailor Shift on her works, but also those influenced by Ivy Echos, providing an extensive picture of her influence.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Step 1: Define all relevant edge types per schema\ncollab_credit_types <- c(\"PerformerOf\", \"ComposerOf\", \"ProducerOf\", \"LyricistOf\", \"MemberOf\")\ninfluence_types <- c(\"CoverOf\", \"InterpolatesFrom\", \"LyricalReferenceTo\", \"DirectlySamples\", \"InStyleOf\")\n\n# Step 2: Get Sailor Shift's node ID\nsailor_vertex_name <- mc1_nodes_clean %>%\n  filter(is_sailor == TRUE) %>%\n  pull(name) %>% first()\n\n# Step 3: Find all Sailor Shift's works (songs/albums she performed or was lyricist of)\nsailor_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% c(\"PerformerOf\", \"LyricistOf\"), from == sailor_vertex_name) %>%\n  pull(to)\n\n# Step 4: Find all Person/MusicalGroup collaborated on Sailor Shift's works (excluding herself)\nsailor_collab_edges <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, to %in% sailor_works, from != sailor_vertex_name)\nsailor_collab_nodes <- mc1_nodes_clean %>%\n  filter(name %in% sailor_collab_edges$from, `Node Type` %in% c(\"Person\", \"MusicalGroup\")) %>%\n  pull(name)\n\n# Step 5: Get Ivy Echos's node ID and works\nivy_echos_name <- mc1_nodes_clean %>%\n  filter(str_detect(node_name, regex(\"Ivy Echos\", ignore_case = TRUE))) %>%\n  pull(name) %>% first()\nivy_works <- mc1_edges_clean %>%\n  filter(`Edge Type` == \"PerformerOf\", from == ivy_echos_name) %>%\n  pull(to)\nivy_works <- mc1_nodes_clean %>%\n  filter(name %in% ivy_works, `Node Type` %in% c(\"Song\", \"Album\")) %>%\n  pull(name)\n\n# Step 6: Find all works influenced by Ivy Echos's works (Ivy Echos's works as destination of influence edges)\nivy_influenced_edges <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_types, to %in% ivy_works)\nivy_influenced_works <- ivy_influenced_edges$from\n\n# Step 7: For each influenced work, get the people/groups involved (collaborators on those works)\nivy_influenced_collab_edges <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, to %in% ivy_influenced_works)\nivy_influenced_collab_nodes <- mc1_nodes_clean %>%\n  filter(name %in% ivy_influenced_collab_edges$from, `Node Type` %in% c(\"Person\", \"MusicalGroup\")) %>%\n  pull(name)\n\n# Step 8: Collect all relevant nodes and edges for the network\nall_relevant_nodes <- unique(c(\n  sailor_vertex_name,\n  sailor_collab_nodes,\n  sailor_works,\n  ivy_echos_name,\n  ivy_works,\n  ivy_influenced_works,\n  ivy_influenced_collab_nodes\n))\n\nall_relevant_edges <- mc1_edges_clean %>%\n  filter(from %in% all_relevant_nodes & to %in% all_relevant_nodes)\n\n# Step 9: Annotate node roles for plotting\nsub_nodes_df <- mc1_nodes_clean %>%\n  filter(name %in% all_relevant_nodes) %>%\n  mutate(\n    node_role = case_when(\n      name == sailor_vertex_name ~ \"Sailor Shift\",\n      name == ivy_echos_name ~ \"Ivy Echos\",\n      name %in% sailor_collab_nodes ~ \"Sailor Shift Collaborator\",\n      name %in% sailor_works ~ \"Sailor Shift Work\",\n      name %in% ivy_works ~ \"Ivy Echos Work\",\n      name %in% ivy_influenced_works ~ \"Work Influenced by Ivy Echos\",\n      name %in% ivy_influenced_collab_nodes ~ \"Person/Group in Influenced Work\",\n      TRUE ~ \"Other\"\n    ),\n    node_color = case_when(\n      node_role == \"Sailor Shift\" ~ \"red\",\n      node_role == \"Ivy Echos\" ~ \"purple\",\n      node_role == \"Sailor Shift Collaborator\" ~ \"blue\",\n      node_role == \"Sailor Shift Work\" ~ \"grey30\",\n      node_role == \"Ivy Echos Work\" ~ \"green\",\n      node_role == \"Work Influenced by Ivy Echos\" ~ \"orange\",\n      node_role == \"Person/Group in Influenced Work\" ~ \"pink\",\n      TRUE ~ \"steelblue\"\n    ),\n    tooltip_text = paste0(\n      \"Name: \", node_name, \"\\n\",\n      \"Type: \", `Node Type`, \"\\n\",\n      \"Role: \", node_role, \"\\n\",\n      ifelse(!is.na(genre), paste0(\"Genre: \", genre, \"\\n\"), \"\"),\n      ifelse(!is.na(release_date), paste0(\"Release: \", release_date, \"\\n\"), \"\")\n    )\n  )\n\n# Step 10: Create tidygraph object and layout\ncareer_graph <- tbl_graph(nodes = sub_nodes_df, edges = all_relevant_edges, directed = TRUE) %>%\n  activate(nodes)\n\nlayout_df <- create_layout(career_graph, layout = \"fr\") %>%\n  as_tibble() %>%\n  select(name, x, y)\n\nnodes_plot <- as_tibble(career_graph) %>%\n  left_join(layout_df, by = \"name\")\n\nedges_plot <- all_relevant_edges %>%\n  left_join(nodes_plot %>% select(name, x, y), by = c(\"from\" = \"name\")) %>%\n  rename(x_from = x, y_from = y) %>%\n  left_join(nodes_plot %>% select(name, x, y), by = c(\"to\" = \"name\")) %>%\n  rename(x_to = x, y_to = y)\n\n# Step 11: Get coordinates for annotation\nsailor_coords <- nodes_plot %>%\n  filter(name == sailor_vertex_name) %>%\n  select(x, y)\nivy_coords <- nodes_plot %>%\n  filter(name == ivy_echos_name) %>%\n  select(x, y)\n\n# Step 12: Plot with ggplot2 + ggiraph, with annotation and legend\np <- ggplot() +\n  geom_segment(\n    data = edges_plot,\n    aes(\n      x = x_from, y = y_from, xend = x_to, yend = y_to,\n      color = `Edge Type`\n    ),\n    alpha = 0.4, arrow = arrow(length = unit(3, 'mm'))\n  ) +\n  scale_color_brewer(palette = \"Dark2\", name = \"Edge Type\") +\n  ggnewscale::new_scale_color() +\n  geom_point_interactive(\n    data = nodes_plot,\n    aes(\n      x = x, y = y,\n      tooltip = tooltip_text,\n      data_id = name,\n      color = node_role,  \n      shape = `Node Type`\n    ),\n    size = 4\n  ) +\n  scale_color_manual(\n    name = \"Node Role\",\n    values = c(\n      \"Sailor Shift\" = \"red\",\n      \"Ivy Echos\" = \"purple\", \n      \"Sailor Shift Collaborator\" = \"blue\",\n      \"Sailor Shift Work\" = \"grey30\",\n      \"Ivy Echos Work\" = \"green\",\n      \"Work Influenced by Ivy Echos\" = \"orange\",\n      \"Person/Group in Influenced Work\" = \"pink\",\n      \"Other\" = \"steelblue\"\n    ),\n    breaks = c(\n      \"Sailor Shift\",\n      \"Ivy Echos\", \n      \"Sailor Shift Collaborator\",\n      \"Sailor Shift Work\",\n      \"Ivy Echos Work\",\n      \"Work Influenced by Ivy Echos\",\n      \"Person/Group in Influenced Work\"\n    )\n  ) +\n  theme_void() +\n  labs(title = \"Sailor Shift's Collaborators and Influence\") +\n  guides(\n    color = guide_legend(\n      title = \"Node Role\",\n      override.aes = list(size = 4),\n      title.position = \"top\"\n    ),\n    shape = guide_legend(\n      title = \"Node Type\",\n      title.position = \"top\"\n    )\n  ) +\n  theme(\n    legend.position = \"right\",\n    legend.box = \"vertical\",\n    plot.title = element_text(size = 20, face = \"bold\") \n  )\n\ngirafe(ggobj = p, width_svg = 12, height_svg = 8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-39-1.png)\n:::\n:::\n\n\n\nThe visualisation shows a wide array of individuals and musical groups who have collaborated with Sailor Shift on various works, this reflects her active engagement within the industry. While there are no instances of Sailor Shift directly influencing other artists, the visualisation reveals that her group, Ivy Echos, has influenced a group and four individuals through a song (Deepsea Fireflies, released in 2025). This demonstrates that Sailor Shift's reach extends beyond her personal collaborations, contributing to a broader legacy through her involvement with Ivy Echos.\n\n## 5.3 Question 1c - How has she influenced collaborators of the broader Oceanus Folk community?\n\nThe network visualisation aims to analyse how Sailor Shift influenced collaborators of the broader Oceanus Folk community.\n\nSailor Shift and her group (Ivy Echos) were primary entities of interest, all works associated to them are compiled to form the foundation of Sailor Shift's musical output. Based on this, several types of influence were analysed:\n\n1.  Direct influence - This includes Oceanus Folk collaborators' works that were explicity influenced by Sailor Shift or Ivy Echos through relationships such as *CoverOf, InterpolatesFrom, LyricalReferenceTo, DirectlySamples,* and *InStyleOf*.\n2.  Indirect (two-step influence) - This occurs when a work by Sailor Shift or Ivy Echos influences an intermediate piece, which then goes on to influence a work by an Oceanus Folk collaborator. These two-step chains shows how Sailor Shift's influence can propagate through the network.\n3.  Cross-collaborator influence - This captures intra-community influence where Oceanus Folk works that were initially influenced by Sailor Shift/Ivy Echos proceeded to influence other Oceanus Folk creations.\n4.  Collaboration-mediated influence - This is transmitted through shared or bridge collaborators.\n    -   Shared collaborators are individuals or groups who worked with both Sailor Shift/Ivy Echos and the Oceanus Folk community\n    -   Bridge Collaborators are those who first worked with Sailor Shift/Ivy Echos and later collaborated with Ocean Folk Contributors.\n\nBased on the influences above, it reveals the full extent of Sailor Shift's reach within the Oceanus Folk Community.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Step 1: Define edge types\ncollab_credit_types <- c(\"PerformerOf\", \"ComposerOf\", \"ProducerOf\", \"LyricistOf\", \"MemberOf\")\ninfluence_edge_types <- c(\"CoverOf\", \"InterpolatesFrom\", \"LyricalReferenceTo\", \"DirectlySamples\", \"InStyleOf\")\n\n# Step 2: Identify all nodes with genre == \"Oceanus Folk\"\noceanus_folk_works <- mc1_nodes_clean %>%\n  filter(genre == \"Oceanus Folk\") %>%\n  pull(name)\n\n# Step 3: Identify all Person and MusicalGroup who are collaborators on Oceanus Folk works\noceanus_folk_collaborators <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, \n         to %in% oceanus_folk_works) %>%\n  inner_join(mc1_nodes_clean %>% select(name, `Node Type`), by = c(\"from\" = \"name\")) %>%\n  filter(`Node Type` %in% c(\"Person\", \"MusicalGroup\")) %>%\n  pull(from) %>%\n  unique()\n\n# Step 4: Get Sailor Shift and Ivy Echos\nsailor_vertex_name <- mc1_nodes_clean %>%\n  filter(is_sailor == TRUE) %>%\n  pull(name) %>% \n  first()\n\nivy_echos_name <- mc1_edges_clean %>%\n  filter(`Edge Type` == \"MemberOf\", from == sailor_vertex_name) %>%\n  pull(to) %>%\n  first()\n\n# Step 5: Find all works that Sailor Shift and Ivy Echos have created/performed\nsailor_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, from == sailor_vertex_name) %>%\n  pull(to)\n\nivy_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, from == ivy_echos_name) %>%\n  pull(to)\n\nsailor_ivy_works <- unique(c(sailor_works, ivy_works))\n\n# Step 6: Find all works that the Oceanus Folk collaborators have worked on\noceanus_collaborator_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, \n         from %in% oceanus_folk_collaborators) %>%\n  pull(to) %>%\n  unique()\n\n# Step 7: Direct influence - Sailor Shift/Ivy Echos works influencing Oceanus collaborator works\ndirect_influence <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         from %in% sailor_ivy_works,\n         to %in% oceanus_collaborator_works) %>%\n  mutate(influence_direction = \"Sailor/Ivy → Oceanus\",\n         pathway_type = \"Direct\")\n\n# Step 8: Indirect influence - Multi-step pathways\n\n# 8a: Find intermediate works that could bridge Sailor Shift/Ivy Echos to Oceanus\n# Works influenced BY Sailor/Ivy\nsailor_influenced_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         from %in% sailor_ivy_works) %>%\n  pull(to) %>%\n  unique()\n\n# Works that influence Sailor/Ivy  \nsailor_influencing_works <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         to %in% sailor_ivy_works) %>%\n  pull(from) %>%\n  unique()\n\n# All intermediate works in potential pathways\nintermediate_works <- unique(c(sailor_influenced_works, sailor_influencing_works))\n\n# 8b: Two-step influence: Sailor/Ivy → Intermediate → Oceanus collaborators\nindirect_influence_step1 <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         from %in% sailor_ivy_works,\n         to %in% intermediate_works) %>%\n  select(sailor_work = from, intermediate_work = to, step1_edge_type = `Edge Type`)\n\nindirect_influence_step2 <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         from %in% intermediate_works,\n         to %in% oceanus_collaborator_works) %>%\n  select(intermediate_work = from, oceanus_work = to, step2_edge_type = `Edge Type`)\n\n# Join to find complete 2-step pathways\ntwo_step_pathways <- indirect_influence_step1 %>%\n  inner_join(indirect_influence_step2, by = \"intermediate_work\") %>%\n  mutate(pathway_type = \"Indirect (2-step)\",\n         influence_direction = \"Sailor/Ivy → Intermediate → Oceanus\")\n\n# 8c: Cross-collaborator influence within Oceanus community\n# Find Oceanus works that were influenced by Sailor and then influenced other Oceanus works\ndirectly_influenced_oceanus_works <- unique(c(direct_influence$to, two_step_pathways$oceanus_work))\n\ncross_collab_influence <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% influence_edge_types,\n         from %in% directly_influenced_oceanus_works,\n         to %in% oceanus_collaborator_works,\n         from != to) %>%\n  mutate(pathway_type = \"Cross-collaborator\",\n         influence_direction = \"Sailor-influenced Oceanus work → Other Oceanus work\")\n\n# Step 9: Collaboration-mediated influence \n\n# 9a: People who worked with both Sailor/Ivy AND Oceanus Folk collaborators\nsailor_ivy_collaborators <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types,\n         to %in% sailor_ivy_works) %>%\n  inner_join(mc1_nodes_clean %>% select(name, `Node Type`), by = c(\"from\" = \"name\")) %>%\n  filter(`Node Type` %in% c(\"Person\", \"MusicalGroup\")) %>%\n  pull(from) %>%\n  unique()\n\nshared_collaborators <- intersect(sailor_ivy_collaborators, oceanus_folk_collaborators)\n\n# 9b. Bridge collaborators - worked with Sailor/Ivy, then later with other Oceanus Folk collaborators\nbridge_collaborators <- setdiff(sailor_ivy_collaborators, oceanus_folk_collaborators)\nbridge_to_oceanus <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types,\n         from %in% bridge_collaborators) %>%\n  inner_join(\n    mc1_edges_clean %>%\n      filter(`Edge Type` %in% collab_credit_types,\n             from %in% oceanus_folk_collaborators) %>%\n      select(shared_work = to),\n    by = c(\"to\" = \"shared_work\")\n  ) %>%\n  select(bridge_person = from, shared_work = to) %>%\n  distinct()\n\n# Step 10: Identify influenced Oceanus Folk Collaborators \n\n# Get all works that show influence from Sailor/Ivy\nall_influenced_oceanus_works <- unique(c(\n  direct_influence$to,\n  two_step_pathways$oceanus_work,\n  cross_collab_influence$to\n))\n\n# Find which Oceanus Folk collaborators worked on these influenced works\ndirectly_influenced_collaborators <- mc1_edges_clean %>%\n  filter(`Edge Type` %in% collab_credit_types, \n         to %in% all_influenced_oceanus_works) %>%\n  inner_join(mc1_nodes_clean %>% select(name, `Node Type`), by = c(\"from\" = \"name\")) %>%\n  filter(`Node Type` %in% c(\"Person\", \"MusicalGroup\"),\n         from %in% oceanus_folk_collaborators) %>%\n  pull(from) %>%\n  unique()\n\n# Add collaborators connected through shared/bridge relationships\ncollaboration_influenced <- unique(c(shared_collaborators, bridge_to_oceanus$bridge_person))\ncollaboration_influenced <- intersect(collaboration_influenced, oceanus_folk_collaborators)\n\ntotal_influenced_collaborators <- unique(c(directly_influenced_collaborators, collaboration_influenced))\n\n# Prepare variables for tabset (initialize as NULL)\np <- NULL\nsummary_stats <- NULL\n\n# Step 11: Enhanced network visualisation and summary statistics \nif(length(total_influenced_collaborators) > 0) {\n  \n  # Collect all relevant nodes for visualization\n  all_pathway_works <- unique(c(\n    sailor_ivy_works,\n    direct_influence$from, direct_influence$to,\n    two_step_pathways$sailor_work, two_step_pathways$intermediate_work, two_step_pathways$oceanus_work,\n    cross_collab_influence$from, cross_collab_influence$to\n  ))\n  \n  all_relevant_people <- unique(c(\n    sailor_vertex_name,\n    ivy_echos_name,\n    total_influenced_collaborators,\n    shared_collaborators,\n    bridge_to_oceanus$bridge_person\n  ))\n  \n  all_viz_nodes <- unique(c(all_pathway_works, all_relevant_people))\n  \n  # Enhanced node classification\n  viz_nodes <- mc1_nodes_clean %>%\n    filter(name %in% all_viz_nodes) %>%\n    mutate(\n      influence_strength = case_when(\n        name %in% direct_influence$to ~ \"Direct Target\",\n        name %in% two_step_pathways$oceanus_work ~ \"Indirect Target\", \n        name %in% cross_collab_influence$to ~ \"Secondary Target\",\n        name %in% shared_collaborators ~ \"Shared Collaborator\",\n        name %in% bridge_to_oceanus$bridge_person ~ \"Bridge Collaborator\",\n        TRUE ~ \"Network Node\"\n      ),\n      node_role = case_when(\n        name == sailor_vertex_name ~ \"Sailor Shift\",\n        name == ivy_echos_name ~ \"Ivy Echos\",\n        name %in% sailor_ivy_works ~ \"Sailor/Ivy Work\",\n        name %in% oceanus_folk_works ~ \"Oceanus Folk Work\",\n        name %in% total_influenced_collaborators ~ \"Influenced Oceanus Collaborator\",\n        name %in% oceanus_folk_collaborators ~ \"Other Oceanus Collaborator\",\n        name %in% intermediate_works ~ \"Intermediate Work\",\n        TRUE ~ \"Other\"\n      ),\n      node_color = case_when(\n        node_role == \"Sailor Shift\" ~ \"red\",\n        node_role == \"Ivy Echos\" ~ \"purple\", \n        node_role == \"Sailor/Ivy Work\" ~ \"gray30\",\n        influence_strength == \"Direct Target\" ~ \"darkred\",\n        influence_strength == \"Indirect Target\" ~ \"orange\",\n        influence_strength == \"Secondary Target\" ~ \"yellow\",\n        influence_strength == \"Shared Collaborator\" ~ \"blue\",\n        influence_strength == \"Bridge Collaborator\" ~ \"cyan\",\n        node_role == \"Influenced Oceanus Collaborator\" ~ \"darkgreen\",\n        node_role == \"Other Oceanus Collaborator\" ~ \"lightgreen\",\n        node_role == \"Intermediate Work\" ~ \"pink\",\n        TRUE ~ \"lightgray\"\n      ),\n      node_size = case_when(\n        node_role %in% c(\"Sailor Shift\", \"Ivy Echos\") ~ 8,\n        influence_strength %in% c(\"Direct Target\", \"Shared Collaborator\") ~ 6,\n        influence_strength %in% c(\"Indirect Target\", \"Bridge Collaborator\") ~ 5,\n        influence_strength == \"Secondary Target\" ~ 4,\n        TRUE ~ 3\n      ),\n      tooltip_text = paste0(\n        \"Name: \", node_name, \"\\n\",\n        \"Role: \", node_role, \"\\n\", \n        \"Influence: \", influence_strength, \"\\n\",\n        \"Type: \", `Node Type`, \"\\n\",\n        ifelse(!is.na(genre), paste0(\"Genre: \", genre), \"\")\n      )\n    )\n  \n  # Collect all relevant edges preserving original Edge Types\n  all_influence_edges <- bind_rows(\n    direct_influence %>% mutate(pathway_category = \"Direct\"),\n    two_step_pathways %>% \n      select(from = sailor_work, to = intermediate_work, `Edge Type` = step1_edge_type) %>%\n      mutate(pathway_category = \"Indirect Step 1\"),\n    two_step_pathways %>% \n      select(from = intermediate_work, to = oceanus_work, `Edge Type` = step2_edge_type) %>%\n      mutate(pathway_category = \"Indirect Step 2\"),\n    cross_collab_influence %>% \n      select(from, to, `Edge Type`) %>%\n      mutate(pathway_category = \"Cross-Collaborator\")\n  )\n  \n  viz_edges <- mc1_edges_clean %>%\n    filter(from %in% all_viz_nodes, to %in% all_viz_nodes) %>%\n    left_join(\n      all_influence_edges %>% select(from, to, pathway_category),\n      by = c(\"from\", \"to\")\n    ) %>%\n    mutate(\n      # Categorize edges for visual emphasis while keeping original Edge Type\n      edge_category = case_when(\n        !is.na(pathway_category) ~ \"Influence Pathway\",\n        `Edge Type` == \"MemberOf\" & from == sailor_vertex_name ~ \"Key Membership\", \n        `Edge Type` %in% collab_credit_types ~ \"Collaboration\",\n        `Edge Type` %in% influence_edge_types ~ \"Other Influence\",\n        TRUE ~ \"Other\"\n      ),\n      edge_alpha = case_when(\n        edge_category == \"Influence Pathway\" ~ 0.9,\n        edge_category == \"Key Membership\" ~ 0.8,\n        edge_category == \"Collaboration\" ~ 0.4,\n        edge_category == \"Other Influence\" ~ 0.6,\n        TRUE ~ 0.2\n      )\n    )\n  \n  # Create network plot\n  influence_graph <- tbl_graph(nodes = viz_nodes, edges = viz_edges, directed = TRUE)\n\n  layout_df <- create_layout(influence_graph, layout = \"fr\") %>%\n    as_tibble() %>%\n    select(name, x, y)\n  \n  nodes_plot <- as_tibble(influence_graph) %>%\n    left_join(layout_df, by = \"name\")\n  \n  edges_plot <- viz_edges %>%\n    left_join(nodes_plot %>% select(name, x, y), by = c(\"from\" = \"name\")) %>%\n    rename(x_from = x, y_from = y) %>%\n    left_join(nodes_plot %>% select(name, x, y), by = c(\"to\" = \"name\")) %>%\n    rename(x_to = x, y_to = y)\n  \n  # Create legend data frame for node colors\n  legend_data <- data.frame(\n    node_color = c(\"red\", \"purple\", \"gray30\", \"darkred\", \"orange\", \"yellow\", \n                   \"blue\", \"cyan\", \"darkgreen\", \"lightgreen\", \"pink\", \"lightgray\"),\n    node_role = c(\"Sailor Shift\", \"Ivy Echos\", \"Sailor/Ivy Work\", \"Direct Target\", \n                  \"Indirect Target\", \"Secondary Target\", \"Shared Collaborator\", \n                  \"Bridge Collaborator\", \"Influenced Oceanus Collaborator\", \n                  \"Other Oceanus Collaborator\", \"Intermediate Work\", \"Other\"),\n    stringsAsFactors = FALSE\n  )\n  \n  p <- ggplot() +\n    geom_segment(\n      data = edges_plot,\n      aes(x = x_from, y = y_from, xend = x_to, yend = y_to,\n          color = `Edge Type`, alpha = edge_alpha),\n      arrow = arrow(length = unit(1.5, 'mm'))\n    ) +\n    scale_alpha_identity() +\n    scale_color_discrete(name = \"Edge Type\") +\n    ggnewscale::new_scale_color() +\n    geom_point_interactive(\n      data = nodes_plot,\n      aes(x = x, y = y, tooltip = tooltip_text, data_id = name,\n          color = node_color, shape = `Node Type`, size = node_size)\n    ) +\n    scale_size_identity() +  \n    scale_color_manual(\n      name = \"Node Role\",\n      values = c(\"red\" = \"red\", \"purple\" = \"purple\", \"pink\" = \"pink\", \"darkred\" = \"darkred\",\n                 \"orange\" = \"orange\", \"yellow\" = \"yellow\", \"blue\" = \"blue\", \"cyan\" = \"cyan\", \n                 \"darkgreen\" = \"darkgreen\", \"lightgreen\" = \"lightgreen\",\n                 \"gray30\" = \"gray30\", \"lightgray\" = \"lightgray\"),\n      labels = setNames(legend_data$node_role, legend_data$node_color),\n      breaks = legend_data$node_color,\n      guide = guide_legend(override.aes = list(size = 4, shape = 16))\n    ) +\n    geom_text(\n      data = nodes_plot %>% filter(node_role == \"Sailor Shift\"),\n      aes(x = x, y = y, label = \"Sailor Shift\"),\n      size = 4, fontface = \"bold\", color = \"red\", vjust = -2\n    ) +\n    theme_void() +\n    theme(\n      legend.position = \"right\",\n      legend.box = \"vertical\",\n      legend.text = element_text(size = 11),\n      legend.title = element_text(size = 16),\n      plot.title = element_text(size = 20, face = \"bold\"), \n      plot.subtitle = element_text(size = 16, face = \"plain\")    \n    ) +\n    labs(\n      title = \"Sailor Shift's Influence on Oceanus Folk Community\",\n      subtitle = str_to_title(\"Influence pathways: Direct (work-to-work), Indirect (via intermediary), Secondary (cross-collaborator), Shared/Bridge (collaboration networks)\")\n    )\n  \n  # Create summary statistics data frame\nsummary_stats <- data.frame(\n  Metric = c(\n    \"Total Oceanus Folk collaborators\",\n    \"Total influenced collaborators\",\n    \"Percentage influenced (%)\",\n    \"\",\n    \"Direct influences\",\n    \"Two-step pathways\", \n    \"Cross-collaborator influences\",\n    \"Shared collaborators\",\n    \"Bridge collaborators\"\n  ),\n  Value = c(\n    length(oceanus_folk_collaborators),\n    length(total_influenced_collaborators),\n    round(100 * length(total_influenced_collaborators) / length(oceanus_folk_collaborators), 1),\n    \"\",\n    nrow(direct_influence),\n    nrow(two_step_pathways),\n    nrow(cross_collab_influence),\n    length(shared_collaborators),\n    length(unique(bridge_to_oceanus$bridge_person))\n  ),\n  stringsAsFactors = FALSE\n)\n}\n```\n:::\n\n\n\n::: panel-tabset\n## Network Visualisation\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ngirafe(ggobj = p, width_svg = 16, height_svg = 12)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-docx/unnamed-chunk-41-1.png)\n:::\n:::\n\n\n\n## Summary Statistics\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nknitr::kable(\n  summary_stats,\n  col.names = c(\"Metric\", \"Count\"),\n  caption = \"Sailor Shift's Influence Analysis Summary\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: Sailor Shift's Influence Analysis Summary\n\n|Metric                           |Count |\n|:--------------------------------|:-----|\n|Total Oceanus Folk collaborators |720   |\n|Total influenced collaborators   |81    |\n|Percentage influenced (%)        |11.2  |\n|                                 |      |\n|Direct influences                |9     |\n|Two-step pathways                |11    |\n|Cross-collaborator influences    |10    |\n|Shared collaborators             |42    |\n|Bridge collaborators             |7     |\n\n\n:::\n:::\n\n\n:::\n\nThe above visualisation focus on the network of influence that Sailor Shift had in the Oceanus Folk community. Out of 720 Oceanus Folk collaborators, she has interacted with 81 collaborators, which is a notable influence as it is more than 10% of the community.\n\nWhile only 9 collaborators have been directly influenced by working closely with her/Ivy Echos, the majority of her impact is indirect. More than half of the influenced collaborators have been shaped indirectly through shared and bridged collaborators. These network-mediated pathways, including two-step and cross-collaborator connections, illustrates how her influence extends beyond those that she worked directly with.\n\nOverall, this showcases how Sailor Shift's influence diffuses dynamically throughout the community where her impact in the community is not only driven by direct collaborations, but also by the broader web of relationships and interactions that connect the Oceanus Folk community.\n\n# 6 References\n\n-   [VAST Challenge 2025](https://vast-challenge.github.io/2025/MC1.html)\n\n-   [PageRank](https://cambridge-intelligence.com/keylines-faqs-social-network-analysis/)\n\n-   [PageRank - Calculate node and edge centrality](https://tidygraph.data-imaginist.com/reference/centrality.html)\n",
    "supporting": [
      "Take-home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}